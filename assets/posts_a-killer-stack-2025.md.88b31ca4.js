import{_ as e,o as s,c as a,h as n}from"./app.6336f0b5.js";const f='{"title":"a killer stack for 2025","description":"","frontmatter":{"title":"a killer stack for 2025","date":"2025-03-23T00:00:00.000Z","author":"Corey DeMarse","gravatar":"74e3ab7e361c4141736de00ad444f90a","twitter":"@coreydemarse","head":[["meta",{"name":"keywords","content":"top 10 full stack developer frameworks in 2025 tech stacks best ultimate killer scalable concurrent bun vue elysia elixir drizzle modern 2025 web app react"}]]},"headers":[{"level":3,"title":"A scalable, fast, killer modern tech stack for 2025","slug":"a-scalable-fast-killer-modern-tech-stack-for-2025"},{"level":2,"title":"Vue.js & TypeScript for the front-end","slug":"vue-js-typescript-for-the-front-end"},{"level":2,"title":"Bun, Elysia & Drizzle for REST APIs","slug":"bun-elysia-drizzle-for-rest-apis"},{"level":2,"title":"Elixir for real-time features","slug":"elixir-for-real-time-features"},{"level":2,"title":"Building at Scale","slug":"building-at-scale"},{"level":2,"title":"","slug":""}],"relativePath":"posts/a-killer-stack-2025.md","lastUpdated":null}',t={name:"posts/a-killer-stack-2025.md"},o=n(`<p>the best scalable stack for modern web developers in 2025</p><hr><p><a href="/blog.html">&lt;- return to blog</a></p><h1 id="vue-bun-elixir" tabindex="-1">Vue, Bun &amp; Elixir <a class="header-anchor" href="#vue-bun-elixir" aria-hidden="true">#</a></h1><h3 id="a-scalable-fast-killer-modern-tech-stack-for-2025" tabindex="-1">A scalable, fast, killer modern tech stack for 2025 <a class="header-anchor" href="#a-scalable-fast-killer-modern-tech-stack-for-2025" aria-hidden="true">#</a></h3><br><img src="https://skillicons.dev/icons?i=vue,bun,elixir"><p>If you&#39;re building a modern web app in 2025 you need a stack that\u2019s fast, scalable, and easy to work with. The days of bloated monolithic frameworks are behind us. Instead this stack uses specialized tools that get the job done efficiently.</p><p><strong>Vue, Bun, and Elixir \u2014 a powerful trifecta</strong> that combines a lightweight frontend, a fast and scalable backend for APIs, and a highly concurrent WebSocket server. This stack gives you speed, flexibility, and most importantly of all - developer joy.</p><p><strong>Why not a monolith or server-side-components?</strong></p><p>It&#39;s simple - speed and scalability. A monolith or server-side-components will never be able to match the speed of a statically served Vue bundle from NGINX or Caddy. It&#39;s more efficient for our backend to only serve a JSON REST API or WebSocket that our statically served client can consume.</p><h2 id="vue-js-typescript-for-the-front-end" tabindex="-1">Vue.js &amp; TypeScript for the front-end <a class="header-anchor" href="#vue-js-typescript-for-the-front-end" aria-hidden="true">#</a></h2><br><img src="https://skillicons.dev/icons?i=vue"><p>We are going to build our front-end using Vue.js and TypeScript, and we are going to make it a single-page-application that takes advantage of lazy-loading and code-splitting. This ensures we can statically serve our entire app while keeping initial bundle size low.</p><p>Vue is a simple front-end framework - it has a wonderful DX and is lightweight and fast. It has a simple learning curve that allows you to build more with less time.</p><p><a href="https://quasar.dev">Quasar</a>, a component library for Vue makes it simple to create amazing apps.</p><p><strong>Vue Component Example (Composition API)</strong></p><div class="language-vue"><span class="copy"></span><pre><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">script</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">setup</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">ref</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">vue</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> count </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">ref</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">0</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">button</span><span style="color:#89DDFF;"> @</span><span style="color:#C792EA;">click</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">count</span><span style="color:#89DDFF;">++</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">Count is: </span><span style="color:#89DDFF;">{{</span><span style="color:#A6ACCD;"> count </span><span style="color:#89DDFF;">}}&lt;/</span><span style="color:#F07178;">button</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">style</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">scoped</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#FFCB6B;">button</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#B2CCD6;">font-weight</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> bold</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">style</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><p><strong>Why not React?</strong></p><p>Vue.js was chosen because it simply provides us less headaches and lets us focus on the fun part - building the app. I&#39;m also firmly convinced that people who like JSX are masochistic freaks, because there is no other way to describe people who think it&#39;s OK to put your markup in a JavaScript function.</p><p>In Vue, larger components or pages can highly benefit from being separated into separate CSS, TS and Vue files using the options API. Smaller and more simple components can benefit as single-file-components using the composition API.</p><p>State management in Vue is simple with Pinia.</p><p>Vue embraces web standards like HTML, CSS, and the DOM, while React replaces them with abstractions.</p><p><strong>React\u2019s Problem:</strong> React\u2019s Virtual DOM re-renders entire components unnecessarily unless you manually optimize it (<code>useMemo</code>, <code>useCallback</code>). Hooks in React introduce unintuitive rules, require <code>useEffect</code> for side effects, and lead to &quot;stale closure&quot; bugs. CSS in JS adds runtime overhead.</p><p>Vue reactively updates only what&#39;s needed. There is also no need for <code>useState</code> or <code>useEffect</code>.</p><h2 id="bun-elysia-drizzle-for-rest-apis" tabindex="-1">Bun, Elysia &amp; Drizzle for REST APIs <a class="header-anchor" href="#bun-elysia-drizzle-for-rest-apis" aria-hidden="true">#</a></h2><br><img src="https://go-skill-icons.vercel.app/api/icons?i=bun,elysia,drizzle"><p>Bun, Elysia &amp; Drizzle makes for a powerful and minimalistic stack for building REST APIs that are fast, typed, and efficient.</p><p>Bun is an all-in-one TypeScript runtime that\u2019s fast, modern, and built from scratch in Zig.</p><p>Bun uses the event loop model of JavaScript, which is very good at handling I/O-bound tasks - perfect for APIs.</p><p>Elysia is a framework built on top of Bun, providing a fast, flexible, and end-to-end type-safe environment for building APIs.</p><p><strong>Elysia Minimal Example</strong></p><div class="language-typescript"><span class="copy"></span><pre><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">Elysia</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">elysia</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Elysia</span><span style="color:#A6ACCD;">()</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">get</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">/</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">Hello World</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">listen</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">3000</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span></code></pre></div><p>Drizzle is a modern, type-safe ORM for TypeScript that lets you interact with your database using an ORM instead of raw SQL.</p><p>Bun is great at doing image manipulation using <a href="https://github.com/lovell/sharp" target="_blank" rel="noopener noreferrer">sharp</a> for endpoints where users need to upload avatars or other images to an S3 bucket.</p><p>Bun also includes a websocket server that is useful for small projects on it&#39;s own. However, you won&#39;t get cool Elixir features like code hot-swapping, high concurrency or fault-tolerance that are useful at scale.</p><p><strong>Why not Elixir for our REST JSON API?</strong></p><p>Elixir is the wrong tool for the job. Elixir\u2019s power lies in real-time systems and fault tolerance. Elixir has characteristics that can make it challenging to write the complex business logic that REST APIs can demand.</p><ul><li>Lack of Object-Oriented structures</li><li>No return early pattern</li><li>Hard to avoid deep nesting of if, case, with statements</li><li>Pattern matching can get messy</li><li>Harder to find Elixir developers</li></ul><p>Elixir was designed for concurrency, fault-tolerance and long-lived connections - not necessarily high-throughput, ultra-low-latency HTTP servers with short-lived connections.</p><h2 id="elixir-for-real-time-features" tabindex="-1">Elixir for real-time features <a class="header-anchor" href="#elixir-for-real-time-features" aria-hidden="true">#</a></h2><br><img src="https://skillicons.dev/icons?i=elixir"><p>So your front-end app happens to require real-time updates. Perhaps you have a dashboard that demands real-time data, or you want a live chat between your users.</p><p>We are going to use Elixir, Cowboy, Octo and Redis to build our real-time features.</p><p><strong>Why Elixir?</strong></p><p>Concurrency and fault-tolerance. Cowboy (Erlang\u2019s HTTP server) efficiently handles WebSocket and SSE connections.</p><p>Elixir runs on BEAM, which supports millions of lightweight processes (not OS threads). Each WebSocket/SSE connection runs in its own process, isolated and crash-safe. Elixir can handle thousands to millions of concurrent connections.</p><p>Elixir also supports hot code swapping, meaning you can update code without restarting WebSocket/SSE connections for zero downtime deploys.</p><p>Erlang/Elixir is battle-tested when it comes to realtime features and is deployed in production by companies like Heroku, Discord and WhatsApp.</p><h2 id="building-at-scale" tabindex="-1">Building at Scale <a class="header-anchor" href="#building-at-scale" aria-hidden="true">#</a></h2><br><img src="https://go-skill-icons.vercel.app/api/icons?i=vue,bun,elysia,drizzle,elixir"><p>If you&#39;re looking to build a web application or API that can handle high traffic, scale effectively, and offer a modern developer experience - the combination of Vue, Bun, and Elixir is an excellent choice.</p><p>This stack provides the speed, scalability, and flexibility required to support millions of users and can meet the demands of modern applications.</p><h2 id="" tabindex="-1"><a class="header-anchor" href="#" aria-hidden="true">#</a></h2><p><a href="/blog.html">&lt;- return to blog</a></p>`,59),l=[o];function r(p,i,c,d,u,y){return s(),a("div",null,l)}var D=e(t,[["render",r]]);export{f as __pageData,D as default};
