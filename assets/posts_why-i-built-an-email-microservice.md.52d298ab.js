import{_ as e,o as i,c as a,g as t}from"./app.f93eccc5.js";const u='{"title":"why i built an email microservice","description":"","frontmatter":{"title":"why i built an email microservice","date":"2024-12-08T00:00:00.000Z","author":"Corey DeMarse","gravatar":"74e3ab7e361c4141736de00ad444f90a","twitter":"@coreydemarse"},"headers":[{"level":3,"title":"microMail - a little nodemailer SMTP microservice","slug":"micromail-a-little-nodemailer-smtp-microservice"},{"level":3,"title":"1. Monoliths and Email Sending: The Struggle","slug":"_1-monoliths-and-email-sending-the-struggle"},{"level":3,"title":"2. Enter the Email Microservice","slug":"_2-enter-the-email-microservice"},{"level":3,"title":"3. Why Bun/TypeScript","slug":"_3-why-bun-typescript"},{"level":3,"title":"4. Using Redis Pub/Sub for Communication","slug":"_4-using-redis-pub-sub-for-communication"},{"level":3,"title":"5. Handlebars for Templating","slug":"_5-handlebars-for-templating"},{"level":3,"title":"6. Simplified Maintenance and Extensibility","slug":"_6-simplified-maintenance-and-extensibility"},{"level":3,"title":"7. Why This Makes Sense for Multiple Services","slug":"_7-why-this-makes-sense-for-multiple-services"},{"level":3,"title":"microMail","slug":"micromail"},{"level":3,"title":"Check out or contribute to microMail","slug":"check-out-or-contribute-to-micromail"}],"relativePath":"posts/why-i-built-an-email-microservice.md","lastUpdated":null}',n={name:"posts/why-i-built-an-email-microservice.md"},s=t('<p>a good case for a microservice, and why email and monoliths don&#39;t mix</p><hr><p><a href="/blog.html">&lt;- return to blog</a></p><h3 id="micromail-a-little-nodemailer-smtp-microservice" tabindex="-1">microMail - a little nodemailer SMTP microservice <a class="header-anchor" href="#micromail-a-little-nodemailer-smtp-microservice" aria-hidden="true">#</a></h3><p>View Project on GitHub</p><p><a href="https://github.com/coreydemarse/micromail" target="_blank" rel="noopener noreferrer"><img src="https://img.shields.io/static/v1?label=&amp;message=microMail&amp;color=000605&amp;logo=github&amp;logoColor=FFFFFF&amp;labelColor=000605" alt="microMail"></a></p><h1 id="why-i-built-an-email-microservice" tabindex="-1">why I built an email microservice <a class="header-anchor" href="#why-i-built-an-email-microservice" aria-hidden="true">#</a></h1><p>When building applications, especially large-scale ones, developers often face the challenge of sending emails. It&#39;s something that seems simple at first glance, but once you start adding more services to the mix \u2014 like a game server or other microservices \u2014 the complexity of handling email notifications can become overwhelming. In monolithic applications, sending emails can be messy, especially as your codebase grows, leading to bloated solutions tied to the application\u2019s main framework.</p><p>This is where microservices come in. I recently built microMail that uses <strong>Redis Pub/Sub</strong> for communication and <strong>Handlebars templates</strong> for rendering emails. Let me walk you through why I chose this approach and how it simplifies email management, particularly in systems with multiple services.</p><h3 id="_1-monoliths-and-email-sending-the-struggle" tabindex="-1">1. <strong>Monoliths and Email Sending: The Struggle</strong> <a class="header-anchor" href="#_1-monoliths-and-email-sending-the-struggle" aria-hidden="true">#</a></h3><p>When you&#39;re working with a monolithic architecture, the framework you\u2019re using typically includes email-sending capabilities. This might be through an integrated library or as part of a broader &quot;notification&quot; module. While this can work for small applications, a few challenges arise as your application scales:</p><ul><li><p><strong>Bloat</strong>: Adding email functionality into a monolith can lead to bloated services. As your codebase grows, email-sending logic becomes intertwined with other responsibilities, making it harder to manage and maintain.</p></li><li><p><strong>Tight Coupling</strong>: In a monolith, email-sending is usually tightly coupled with the business logic, meaning that if you need to modify your email system, you\u2019re modifying core parts of your application, potentially affecting unrelated functionality.</p></li><li><p><strong>Scalability Issues</strong>: A monolithic framework&#39;s email-handling capabilities might not scale well when you introduce microservices or external systems, such as a game server, that also need to send emails.</p></li></ul><h3 id="_2-enter-the-email-microservice" tabindex="-1">2. <strong>Enter the Email Microservice</strong> <a class="header-anchor" href="#_2-enter-the-email-microservice" aria-hidden="true">#</a></h3><p>With these challenges in mind, I decided to create a dedicated email microservice that could be used by any other service in the ecosystem, whether it\u2019s the monolith, a game server, or any other microservice.</p><h3 id="_3-why-bun-typescript" tabindex="-1">3. <strong>Why Bun/TypeScript</strong> <a class="header-anchor" href="#_3-why-bun-typescript" aria-hidden="true">#</a></h3><p>I chose <strong>Bun/TypeScript</strong> for a few reasons:</p><ul><li><p><strong>Awesome</strong>: It&#39;s new and cool</p></li><li><p><strong>Familiarity</strong>: TypeScript\u2019s syntax is familiar to many developers, and using it in a Bun environment offers optimal performance.</p></li><li><p><strong>Asynchronous Support</strong>: Sending emails is inherently asynchronous, and TypeScript, paired with Bun, makes handling async code more straightforward through <code>async/await</code> and promises.</p></li></ul><h3 id="_4-using-redis-pub-sub-for-communication" tabindex="-1">4. <strong>Using Redis Pub/Sub for Communication</strong> <a class="header-anchor" href="#_4-using-redis-pub-sub-for-communication" aria-hidden="true">#</a></h3><p>In the microservices world, one of the key concerns is communication between services. Redis Pub/Sub is a great way to handle this.</p><ul><li><p><strong>Part of the stack</strong>: If you&#39;re building any service, you will most likely already have Redis running to handle events, caching or as a key-value store.</p></li><li><p><strong>Decoupling Services</strong>: By using Redis Pub/Sub, the email microservice is decoupled from other services. Services can &quot;publish&quot; email requests to a Redis channel, and the email microservice simply &quot;subscribes&quot; to that channel to send emails when triggered.</p></li><li><p><strong>Scalability</strong>: Redis Pub/Sub is lightweight and efficient. It works well for high-throughput applications that need to send a large number of emails across various services. Redis can handle thousands of messages per second, and the microservice can scale independently to meet demand.</p></li><li><p><strong>Real-time Communication</strong>: Redis ensures near real-time communication, which is important for sending timely email notifications. Whether a game server needs to send an in-game event email or the monolith needs to send a password reset, Redis provides a fast and reliable way to send those requests.</p></li></ul><h3 id="_5-handlebars-for-templating" tabindex="-1">5. <strong>Handlebars for Templating</strong> <a class="header-anchor" href="#_5-handlebars-for-templating" aria-hidden="true">#</a></h3><p>Email templates are a crucial part of any application. You don\u2019t want to hardcode email content; instead, you want to use templates that are reusable and easy to update.</p><ul><li><p><strong>Separation of Concerns</strong>: Using <strong>Handlebars templates</strong> to render emails allows for clear separation between the application logic and email content. The template defines the structure and style of the email, while the microservice fills in the dynamic content (like a user\u2019s name or a link) when sending the email.</p></li><li><p><strong>Flexibility</strong>: Handlebars provides an intuitive syntax for embedding dynamic data into the template. This is especially useful when the content of the email depends on user data, like personalized greeting messages or order details. The templating engine also allows for partials, helpers, and even conditional logic, making it powerful enough for complex email needs.</p></li><li><p><strong>Consistency</strong>: Using a templating engine ensures that emails across all services (the monolith, game servers, or other microservices) maintain a consistent format. Whether it\u2019s a password reset, user notification, or game achievement email, Handlebars ensures the emails are rendered uniformly.</p></li></ul><h3 id="_6-simplified-maintenance-and-extensibility" tabindex="-1">6. <strong>Simplified Maintenance and Extensibility</strong> <a class="header-anchor" href="#_6-simplified-maintenance-and-extensibility" aria-hidden="true">#</a></h3><p>One of the key advantages of this approach is the ease of <strong>maintenance</strong> and <strong>extensibility</strong>:</p><ul><li><p>If I need to update the email templates (e.g., change the design or content of password reset emails), I only have to update the Handlebars templates in one place \u2014 the email microservice.</p></li><li><p>If I want to add new types of emails (e.g., a new game event notification or a new feature in the monolith), I can easily do so by simply adding a new template. There&#39;s no need to alter the core application logic, which is a significant improvement over the monolithic approach.</p></li><li><p>It\u2019s also easy to integrate new services into the system. If another service or external system needs to send emails, all it has to do is publish a message to the Redis channel. The email microservice will handle the rest.</p></li></ul><h3 id="_7-why-this-makes-sense-for-multiple-services" tabindex="-1">7. <strong>Why This Makes Sense for Multiple Services</strong> <a class="header-anchor" href="#_7-why-this-makes-sense-for-multiple-services" aria-hidden="true">#</a></h3><p>In a system with multiple services, each responsible for different pieces of the application, having a centralized, dedicated email service is a clear win:</p><ul><li><p><strong>Decoupling</strong>: Instead of forcing every service to know how to send emails, they simply need to know how to interact with the email service via Redis. The email service handles the rendering, sending, and error handling.</p></li><li><p><strong>Consistency</strong>: A single microservice can ensure that all outgoing emails, regardless of which service is triggering them, are consistent in formatting and content. You avoid discrepancies between, say, the emails sent by the game server versus those sent by the monolith.</p></li><li><p><strong>Avoiding Bloat</strong>: Monolithic frameworks can often bloat with dependencies you don\u2019t need. A dedicated email microservice keeps things lightweight by only focusing on the task of sending templated emails. This can be far easier to manage than trying to use an email feature from a large, monolithic framework.</p></li></ul><h3 id="micromail" tabindex="-1">microMail <a class="header-anchor" href="#micromail" aria-hidden="true">#</a></h3><p>Building this email microservice using TypeScript, Redis Pub/Sub, and Handlebars templates has significantly improved the ability to handle email notifications in a scalable and maintainable way. By decoupling email-sending logic from the core application and centralizing it in a microservice, we&#39;re able to simplify the process, avoid bloat, and ensure consistency across various services, whether it\u2019s a game server or a traditional monolith.</p><p>microMail is a very small microservice and comes in at around 300~ lines of code and can handle thousands of emails per second.</p><h3 id="check-out-or-contribute-to-micromail" tabindex="-1">Check out or contribute to microMail <a class="header-anchor" href="#check-out-or-contribute-to-micromail" aria-hidden="true">#</a></h3><p>View Project on GitHub</p><p><a href="https://github.com/coreydemarse/micromail" target="_blank" rel="noopener noreferrer"><img src="https://img.shields.io/static/v1?label=&amp;message=microMail&amp;color=000605&amp;logo=github&amp;logoColor=FFFFFF&amp;labelColor=000605" alt="microMail"></a></p><p><a href="/blog.html">&lt;- return to blog</a></p>',36),o=[s];function r(l,c,m,h,d,p){return i(),a("div",null,o)}var f=e(n,[["render",r]]);export{u as __pageData,f as default};
