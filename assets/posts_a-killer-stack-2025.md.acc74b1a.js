import{_ as e,o as s,c as a,g as n}from"./app.f93eccc5.js";const m='{"title":"a killer stack for 2025","description":"","frontmatter":{"title":"a killer stack for 2025","date":"2025-03-23T00:00:00.000Z","author":"Corey DeMarse","gravatar":"74e3ab7e361c4141736de00ad444f90a","twitter":"@coreydemarse"},"headers":[{"level":3,"title":"An opinionated, but killer modern tech stack for 2025","slug":"an-opinionated-but-killer-modern-tech-stack-for-2025"},{"level":2,"title":"Vue.js & TypeScript for the front-end","slug":"vue-js-typescript-for-the-front-end"},{"level":2,"title":"Sinatra for RESTful JSON APIs","slug":"sinatra-for-restful-json-apis"},{"level":2,"title":"Elixir for real-time features","slug":"elixir-for-real-time-features"},{"level":2,"title":"Tools in a Box","slug":"tools-in-a-box"},{"level":2,"title":"","slug":""}],"relativePath":"posts/a-killer-stack-2025.md","lastUpdated":null}',o={name:"posts/a-killer-stack-2025.md"},t=n(`<p>a carefully curated stack for modern web developers in 2025</p><hr><p><a href="/blog.html">&lt;- return to blog</a></p><h1 id="vue-sinatra-elixir" tabindex="-1">Vue, Sinatra &amp; Elixir <a class="header-anchor" href="#vue-sinatra-elixir" aria-hidden="true">#</a></h1><h3 id="an-opinionated-but-killer-modern-tech-stack-for-2025" tabindex="-1">An opinionated, but killer modern tech stack for 2025 <a class="header-anchor" href="#an-opinionated-but-killer-modern-tech-stack-for-2025" aria-hidden="true">#</a></h3><br><img src="https://skillicons.dev/icons?i=vue,ruby,elixir"><p>If you&#39;re building a modern web app in 2025 you need a stack that\u2019s fast, scalable, and easy to work with. The days of bloated monolithic frameworks are behind us. Instead this stack uses specialized tools that get the job done efficiently.</p><p><strong>Vue, Sinatra, and Elixir \u2014 a powerful trifecta</strong> that combines a lightweight frontend, a simple backend for APIs, and a blazing-fast WebSocket server. This stack gives you speed, flexibility, and most importantly of all - developer joy.</p><p><strong>Why not a monolith or server-side-components?</strong></p><p>It&#39;s simple - speed and scalability. A monolith or server-side-components will never be able to match the speed of a statically served Vue bundle from NGINX or Caddy. It&#39;s more efficient for our backend to only serve a JSON REST API or WebSocket that our statically served client can consume.</p><h2 id="vue-js-typescript-for-the-front-end" tabindex="-1">Vue.js &amp; TypeScript for the front-end <a class="header-anchor" href="#vue-js-typescript-for-the-front-end" aria-hidden="true">#</a></h2><br><img src="https://skillicons.dev/icons?i=vue"><p>We are going to build our front-end using Vue.js and TypeScript, and we are going to make it a single-page-application that takes advantage of lazy-loading and code-splitting. This ensures we can statically serve our entire app while keeping initial bundle size low.</p><p>Vue is a simple front-end framework - it has a wonderful DX and is lightweight and fast. It has a simple learning curve that allows you to build more with less time.</p><p><a href="https://quasar.dev">Quasar</a>, a component library for Vue makes it simple to create amazing apps.</p><p><strong>Here is a minimal example of a Vue SFC</strong></p><div class="language-vue"><span class="copy"></span><pre><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">script</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">setup</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">ref</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">vue</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> count </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">ref</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">0</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">button</span><span style="color:#89DDFF;"> @</span><span style="color:#C792EA;">click</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">count</span><span style="color:#89DDFF;">++</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">Count is: </span><span style="color:#89DDFF;">{{</span><span style="color:#A6ACCD;"> count </span><span style="color:#89DDFF;">}}&lt;/</span><span style="color:#F07178;">button</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">style</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">scoped</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#FFCB6B;">button</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#B2CCD6;">font-weight</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> bold</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">style</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><p><strong>Why not React?</strong></p><p>Vue.js was chosen because it simply provides us less headaches and lets us focus on the fun part - building the app. I&#39;m also firmly convinced that people who like JSX are masochistic freaks, because there is no other way to describe people who think it&#39;s OK to put your markup in a JavaScript function.</p><p>Big components or pages can highly benefit from being seperated into seperate CSS, TS and Vue files using the options API. Smaller and more simple components can benefit as single-file-components using the composition API.</p><p>State management in Vue is simple with Pinia.</p><p>Vue embraces web standards like HTML, CSS, and the DOM, while React replaces them with abstractions.</p><p><strong>React\u2019s Problem:</strong> React\u2019s Virtual DOM re-renders entire components unnecessarily unless you manually optimize it (<code>useMemo</code>, <code>useCallback</code>). Hooks in React introduce unintuitive rules, require <code>useEffect</code> for side effects, and lead to &quot;stale closure&quot; bugs. CSS in JS adds runtime overhead.</p><p>Vue reactively updates only what&#39;s needed. There is also no need for <code>useState</code> or <code>useEffect</code>.</p><h2 id="sinatra-for-restful-json-apis" tabindex="-1">Sinatra for RESTful JSON APIs <a class="header-anchor" href="#sinatra-for-restful-json-apis" aria-hidden="true">#</a></h2><br><img src="https://skillicons.dev/icons?i=ruby"><p>We are going to be building a RESTful JSON API that our Vue app can consume and we don&#39;t need all the bells and whistles that comes with Ruby on Rails or any other monolithic framework. Sinatra is a small microframework that makes building APIs a dream.</p><p>This API is going to handle your apps business logic - and Sinatra/ActiveRecord is the tool for the job. You can use ActiveRecord with Sinatra using the <code>sinatra-activerecord</code> gem.</p><p>Sinatra APIs are simple to write and easy to deploy and scale.</p><p><strong>Here is a minimal example of a Sinatra API</strong></p><div class="language-ruby"><span class="copy"></span><pre><code><span class="line"><span style="color:#F78C6C;">require</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">sinatra</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#F78C6C;">require</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">json</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">get </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">/hello</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">do</span></span>
<span class="line"><span style="color:#A6ACCD;">  content_type </span><span style="color:#89DDFF;">:json</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">message:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Hello from Sinatra</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}.</span><span style="color:#A6ACCD;">to_json</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">end</span></span>
<span class="line"></span></code></pre></div><p><strong>Why Ruby?</strong></p><p>Ruby is simple and has a great DX. This allows us to move fast and build more with much less headaches. Ruby, Sinatra and ActiveRecord combined makes it easy to write complex business logic.</p><p>When it comes to performance, Sinatra is &quot;fast-enough&quot; for most applications. We can scale horizontally if necessary. Sinatra also leverages Rack middleware making it easy to add things like rate-limiting.</p><p>Ruby/Sinatra/ActiveRecord is battle-tested and used in production by companies like Apple, GitHub, Shopify &amp; Twitch.</p><p><strong>Why not Elixir for our REST JSON API?</strong></p><p>Elixir is the wrong tool for the job. Elixir\u2019s power lies in concurrency, real-time systems, and fault tolerance. Elixir has characteristics that can make it challenging to write the complex business logic that REST APIs can demand.</p><ul><li>Lack of Object-Oriented structures</li><li>No return early pattern</li><li>Immutability inconvenient for complex state management</li><li>Hard to avoid deep nesting of if, case, with statements</li><li>Pattern matching can get messy</li><li>Harder to find Elixir developers</li></ul><p>Elixir is great for our realtime features that require concurrent connections (like websockets), but not-so-great for the non-realtime features that are heavy in business logic like our RESTful JSON APIs.</p><h2 id="elixir-for-real-time-features" tabindex="-1">Elixir for real-time features <a class="header-anchor" href="#elixir-for-real-time-features" aria-hidden="true">#</a></h2><br><img src="https://skillicons.dev/icons?i=elixir"><p>So your front-end app happens to require real-time updates. Perhaps you have a dashboard that demands real-time data about device metrics, or you want a live chat between your users.</p><p>We are going to use Elixir, Cowboy, Octo and Redis to build our real-time features.</p><p><strong>Why Elixir?</strong></p><p>Concurrency and fault-tolerance. Cowboy (Erlang\u2019s HTTP server) efficiently handles WebSocket and SSE connections.</p><p>Elixir runs on BEAM, which supports millions of lightweight processes (not OS threads). Each WebSocket/SSE connection runs in its own process, isolated and crash-safe. Elixir can handle thousands to millions of concurrent connections.</p><p>Elixir also supports hot code swapping, meaning you can update code without restarting WebSocket/SSE connections for zero downtime deploys.</p><p>Erlang/Elixir is battle-tested when it comes to realtime features and is deployed in production by companies like Heroku, Discord and WhatsApp.</p><h2 id="tools-in-a-box" tabindex="-1">Tools in a Box <a class="header-anchor" href="#tools-in-a-box" aria-hidden="true">#</a></h2><br><img src="https://skillicons.dev/icons?i=vue,ruby,elixir"><p>At the end of the day - programming languages and the frameworks that come with them are just tools in a box.</p><p>Informing yourself of the strengths and weaknesses of each language and framework can empower you to make better choices when it comes to building a solution.</p><h2 id="" tabindex="-1"><a class="header-anchor" href="#" aria-hidden="true">#</a></h2><p><a href="/blog.html">&lt;- return to blog</a></p>`,59),l=[t];function r(i,p,c,d,u,h){return s(),a("div",null,l)}var f=e(o,[["render",r]]);export{m as __pageData,f as default};
